In software engineering interviews, candidates are often asked about various design patterns, which are reusable solutions to commonly occurring problems in software design. Here are some of the most popular design patterns frequently asked about:

1. **Singleton Pattern**: Ensures that a class has only one instance and provides a global point of access to that instance.

2. **Factory Method Pattern**: Defines an interface for creating an object but allows subclasses to alter the type of objects that will be created.

3. **Builder Pattern**: Separates the construction of a complex object from its representation, allowing the same construction process to create different representations.

4. **Adapter Pattern**: Allows incompatible interfaces to work together by providing a wrapper that converts the interface of a class into another interface clients expect.

5. **Observer Pattern**: Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.

6. **Decorator Pattern**: Attaches additional responsibilities to an object dynamically, providing a flexible alternative to subclassing for extending functionality.

7. **Strategy Pattern**: Defines a family of algorithms, encapsulates each one, and makes them interchangeable, allowing the algorithm to vary independently from clients that use it.

8. **Proxy Pattern**: Provides a surrogate or placeholder for another object to control access to it, add functionality, or provide lazy initialization.

9. **Command Pattern**: Encapsulates a request as an object, thereby allowing for parameterization of clients with queues, requests, and operations.

10. **Template Method Pattern**: Defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure.

These are just a few examples, and there are many more design patterns out there. It's essential to understand the principles behind each pattern, including when and how to apply them appropriately to solve specific design problems. During interviews, be prepared to discuss real-world scenarios where these patterns might be useful, as well as their advantages, disadvantages, and potential trade-offs.